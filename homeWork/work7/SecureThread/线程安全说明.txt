
**************************************Author 沈********************************************
实验目的：本次实验针对Demo1，Demo2和Demo3进行测试，发现线程安全问题，
	并加以调整使得线程安全可靠

安全问题：Demo1：
	        Demo1中是用两个线程对一个List进行更改，当然会出现问题了；于是
	我首先考虑到的是Synchronized{ }来进行同步限制避免对list的处理中退出而
	另一个线程接着继续处理，就会出现重复处理的情况。
	
	Demo3与Demo2：
	       Demo2用于向相同ist中插入数据，Demo3用于向相同list中删除数据；实
	验中创建多个Demo2线程和一个Demo3线程对同个List进行操作，因为没有使
	用Synchronized{ }自然就会出问题，可能出现重复写入重复删除而抛出异常。

解决方案：Demo1：
	    Demo1中自然会想到对List上锁，但是要在循环内上锁，再循环外上锁最终只
	会有一个线程起作用，于是很自然的选择在while内上锁，但是抛出java.util.
	ConcurrentModificationException异常，意思就是不能同时遍历且删除，网上
	说可以先遍历然后将要删除的数据存入新List中，遍历完成后删除List，说干就干，
	注意给新创建的List加上锁就OK了

	Demo2与Demo3：
	    Demo2与Demo3中同样要在while循环内加上synchronized就OK了，这里不
	再嗦了。

思考：
	  线程安全问题至关重要，好的线程事半功倍，不安全的线程适得其反；加强对并发
	编程的理解和训练；在并发编程这块知识点很多，JDK自带的线程工具（Fork-Join 
	分而治之等）就很多够折腾了；本实验中可以引入Volatile/ThreadLocal类型定义更、
	加方便可靠。对于synchronized这种强性质的锁可以采用更强的机制（wait/notifyAll）
	来实现。
			谢谢观看！ 	----知飞

****************************************************************************************************